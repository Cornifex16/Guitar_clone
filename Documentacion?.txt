¬°Claro que s√≠\! Aqu√≠ tienes una documentaci√≥n t√©cnica del estado actual del proyecto (**Rust Hero v0.1 - Prototipo Visual**) y la gu√≠a paso a paso para integrar el audio.

Esta documentaci√≥n te servir√° para recordar c√≥mo est√° estructurado el c√≥digo antes de meterte en la complejidad del sonido.

-----

# üìò Documentaci√≥n del Proyecto: Rust Hero (v0.1)

## 1\. Visi√≥n General

Rust Hero es un motor de juego de ritmo desarrollado en **Rust** utilizando el framework **Bevy (ECS)**. El proyecto est√° dise√±ado con una arquitectura modular que separa la l√≥gica de creaci√≥n de canciones (**Editor**) de la l√≥gica de juego (**Gameplay**), compartiendo definiciones base (**Core**).

## 2\. Arquitectura de M√≥dulos

El proyecto se divide en 5 m√≥dulos principales bajo `src/`:

### A. Core (`src/core/`)

El coraz√≥n compartido. Define las estructuras de datos que ambos modos (Juego y Editor) necesitan entender.

  * **`audio.rs` (Conductor):** Define el recurso `Conductor`. Es el reloj maestro. Almacena `song_position` (segundos actuales) y `bpm`.
  * **`chart.rs` (Datos):** Define qu√© es una `Note` (tiempo, carril, duraci√≥n) y un `SongChart` (la canci√≥n completa). Utiliza `Serde` para poder guardar/cargar estos datos en JSON.

### B. Editor (`src/editor/`)

Sistema encargado de grabar la entrada del usuario y generar archivos de niveles (`.json`).

  * **`recorder.rs`:** Escucha el teclado y guarda los eventos "crudos" (tiempo exacto y tecla) en memoria RAM (`RecordingSession`).
  * **`visualizer.rs`:** Dibuja gizmos (l√≠neas y c√≠rculos) en tiempo real para dar feedback visual al creador.
  * **`quantizer.rs`:** Contiene la l√≥gica matem√°tica (Snap-to-Grid) para ajustar los errores humanos al ritmo m√°s cercano (semicorcheas).
  * **`io.rs`:** Maneja la escritura en disco. Convierte la sesi√≥n de grabaci√≥n en un archivo JSON al presionar `Enter`.

### C. Gameplay (`src/gameplay/`)

El motor de juego en s√≠. Lee el JSON y ejecuta la partida.

  * **`spawner.rs`:** Lee el `SongChart` y hace aparecer las notas (`Entity`) unos segundos antes de que deban sonar.
  * **`movement.rs`:** Controla la posici√≥n vertical (`Y`) de las notas bas√°ndose en la diferencia entre el tiempo de la nota y el tiempo del `Conductor`.
  * **`scoring.rs`:** Detecta cuando el jugador presiona una tecla. Valida si hay una nota dentro de la "ventana de hit" (margen de error) y decide si es acierto o fallo.

### D. UI (`src/ui/`)

La interfaz gr√°fica y elementos est√°ticos.

  * **`menu.rs`:** Pantalla de inicio para cambiar entre estados.
  * **`layout.rs`:** Dibuja el tablero de juego (l√≠neas del m√°stil y receptores de colores).
  * **`hud.rs`:** Muestra textos en pantalla (Puntaje).

### E. States (`src/states.rs`)

Define la m√°quina de estados finitos del juego:

1.  **Menu:** Pantalla de t√≠tulo.
2.  **Editor:** Modo de creaci√≥n.
3.  **Game:** Modo de juego.

-----

## 3\. Flujo de Datos

1.  **Entrada (Editor):** El usuario toca el teclado siguiendo el ritmo (mentalmente por ahora).
2.  **Procesamiento:** El sistema guarda los tiempos. Al guardar, se "cuantizan" (limpian).
3.  **Persistencia:** Se genera un archivo `output.json`.
4.  **Consumo (Juego):** El juego lee ese JSON, crea las notas y verifica la sincronizaci√≥n.

-----

# üõ†Ô∏è Gu√≠a de Implementaci√≥n de Audio

Ahora que tienes la base visual, vamos a agregar el "motor" real del juego: la m√∫sica. Usaremos la librer√≠a `bevy_kira_audio`.

### Paso 1: Dependencias

Modifica tu archivo `Cargo.toml`. Aseg√∫rate de usar la versi√≥n compatible con tu versi√≥n de Bevy (si usas Bevy 0.13, Kira suele ser la 0.19).

```toml
[dependencies]
bevy = "0.13" 
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
# Agregamos Kira con soporte para OGG (recomendado) y MP3
bevy_kira_audio = { version = "0.19", features = ["ogg", "mp3"] } 
```

### Paso 2: Configuraci√≥n en `main.rs`

Debemos registrar el plugin de audio para que Bevy sepa usarlo.

```rust
// src/main.rs
use bevy::prelude::*;
use bevy_kira_audio::prelude::*; // <--- Importar

// ... imports de tus m√≥dulos ...

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(AudioPlugin) // <--- INICIALIZAR AQU√ç
        // ... resto de plugins (Core, UI, etc.)
        .run();
}
```

### Paso 3: Preparar Recursos

1.  Crea una carpeta llamada `audio` dentro de `assets/`.
2.  Consigue un archivo de m√∫sica (preferiblemente `.ogg` para evitar latencia, aunque `.mp3` sirve).
3.  Gu√°rdalo como: `assets/audio/song.ogg`.

### Paso 4: Integraci√≥n en Gameplay

Ahora haremos que la m√∫sica suene al entrar al juego y que el `Conductor` (nuestro reloj) se sincronice.

Edita **`src/gameplay/mod.rs`**:

```rust
use bevy::prelude::*;
use bevy_kira_audio::prelude::*; // Importar Kira
use crate::states::AppState;
use crate::core::Conductor; // Importar Conductor

// ... imports de sistemas ...

pub struct GamePlugin;

impl Plugin for GamePlugin {
    fn build(&self, app: &mut App) {
        app
            .init_resource::<spawner::SpawnCursor>()
            // Al entrar al juego, ejecutamos setup_game
            .add_systems(OnEnter(AppState::Game), setup_game)
            // Al salir, limpiamos
            .add_systems(OnExit(AppState::Game), cleanup_game)
            // ... tus sistemas de Update ...
            ;
    }
}

fn setup_game(
    asset_server: Res<AssetServer>,
    audio: Res<Audio>,             // Recurso de Audio
    mut conductor: ResMut<Conductor>,
    mut cursor: ResMut<spawner::SpawnCursor>,
) {
    // 1. Reiniciar cursor de notas
    cursor.next_note_index = 0;

    // 2. Configurar el Conductor
    conductor.song_position = 0.0;
    conductor.is_playing = true; // Esto activa el reloj en core/audio.rs

    // 3. Cargar y reproducir m√∫sica
    let music = asset_server.load("audio/song.ogg");
    audio.play(music);
    
    println!("‚ô™ M√∫sica iniciada ‚ô™");
}

fn cleanup_game(
    mut commands: Commands,
    audio: Res<Audio>, 
    mut conductor: ResMut<Conductor>,
    query: Query<Entity, With<crate::core::Note>>,
) {
    // Detener m√∫sica y reloj
    audio.stop();
    conductor.is_playing = false;

    // Limpiar notas visuales
    for entity in query.iter() {
        commands.entity(entity).despawn_recursive();
    }
}
```

### Paso 5: Integraci√≥n en el Editor (Opcional pero recomendado)

Para poder crear mapas siguiendo el ritmo real, necesitas escuchar la m√∫sica en el editor tambi√©n.

Edita **`src/editor/mod.rs`** y crea/modifica el sistema de entrada:

```rust
// ... imports ...
use bevy_kira_audio::prelude::*; 
use crate::core::Conductor;

// En tu impl Plugin:
// .add_systems(OnEnter(AppState::Editor), setup_editor_music)
// .add_systems(OnExit(AppState::Editor), stop_editor_music)

fn setup_editor_music(
    asset_server: Res<AssetServer>,
    audio: Res<Audio>,
    mut conductor: ResMut<Conductor>,
) {
    conductor.song_position = 0.0;
    conductor.is_playing = true;
    
    let music = asset_server.load("audio/song.ogg");
    audio.play(music);
}

fn stop_editor_music(audio: Res<Audio>, mut conductor: ResMut<Conductor>) {
    audio.stop();
    conductor.is_playing = false;
}
```

-----

### Verificaci√≥n Final

Una vez hayas hecho estos pasos:

1.  Ejecuta `cargo run`.
2.  Entra al "Modo Editor" -\> Deber√≠a sonar la m√∫sica. Graba unas notas al ritmo.
3.  Presiona `Enter` (aseg√∫rate de haber creado la carpeta `assets/charts` manualmente para evitar el crash).
4.  Sal y vuelve a entrar.
5.  Entra a "Jugar Canci√≥n" -\> Deber√≠a sonar la m√∫sica y las notas deber√≠an caer sincronizadas con lo que grabaste.